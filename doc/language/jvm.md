# jvm 原理

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [jvm 原理](#jvm-原理)
  - [创建一个空 Object 占用多少内存](#创建一个空-object-占用多少内存)
  - [类加载器](#类加载器)
    - [类加载器分类](#类加载器分类)
    - [类加载机制一:全盘委托](#类加载机制一全盘委托)
    - [类加载机制二：双亲委派](#类加载机制二双亲委派)
  - [jvm 内存模型](#jvm-内存模型)
    - [java 内存划分](#java-内存划分)
    - [Java 堆内存划分（年轻代）](#java-堆内存划分年轻代)
    - [Java 堆内存划分（老年代）](#java-堆内存划分老年代)
    - [Java 堆内存划分（持久代）](#java-堆内存划分持久代)
  - [常见垃圾回收方法](#常见垃圾回收方法)
  - [java 垃圾回收算法](#java-垃圾回收算法)
  - [jvm 中的垃圾回收器](#jvm-中的垃圾回收器)
    - [Serial 收集器（新生代，复制算法）](#serial-收集器新生代复制算法)
    - [ParNew 收集器（新生代，复制算法）](#parnew-收集器新生代复制算法)
    - [Parallel Scavenge 收集器（新生代，复制算法）](#parallel-scavenge-收集器新生代复制算法)
    - [Serial Old 收集器（老年代，标记-整理算法）](#serial-old-收集器老年代标记-整理算法)
    - [Parallel Old 收集器（老年代，标记-整理算法）](#parallel-old-收集器老年代标记-整理算法)
    - [CMS 收集器（老年代，标记-清除算法）](#cms-收集器老年代标记-清除算法)
    - [G1 收集器（标记-整理）](#g1-收集器标记-整理)
    - [CMS 和 G1 收集器的区别？](#cms-和-g1-收集器的区别)
    - [触发垃圾回收的场景](#触发垃圾回收的场景)
    - [stop-the-world](#stop-the-world)
  - [java 的四种引用类型](#java-的四种引用类型)
  - [触发内存泄漏的场景](#触发内存泄漏的场景)
  - [触发栈内存溢出的场景](#触发栈内存溢出的场景)
  - [JVM 如何调优](#jvm-如何调优)
  - [JVM 相关工具](#jvm-相关工具)
  - [java 命令常用参数](#java-命令常用参数)

<!-- /code_chunk_output -->

## 创建一个空 Object 占用多少内存

1. Object obj = new Object()，其中 obj 是一个指向对象的引用，引用长度决定了 Java 的寻址能力，32 位 JDK 是 4 字节，64 位 JDK 是 8 字节
2. 64 位系统 引用占 8 字节，对象占 16 字节，共 24 字节，32 位系统引用站 4 字节，对象占 8 字节，共 12 字节

## 类加载器

### 类加载器分类

1. BootstrapClassLoader 启动加载类，主要加载核心类库（JRE 的 lib）
2. ExtClassLoader 扩展类加载器，加载 JRE 的 lib/ext 下的 class 文件和 jar 包
3. AppClassLoader 加载当前应用的 classpath 的所有类
4. BootstrapClassLoader 对 Java 不可见，当获取父加载器为 null 时说明是顶级类加载器

### 类加载机制一:全盘委托

当一个 ClassLoader 装载一个类时，除非显示地使用另一个 ClassLoader，则该类所依赖及引用的类也由这个 CladdLoader 载入。

### 类加载机制二：双亲委派

- 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载才会尝试自己去加载。
- 目的是为了避免重复加载，已经加载的无需加载。更加安全，避免了随意加载核心 class。
- 自定义类加载器如果重写了 loadClass 方法会破坏双亲委派模式。

## jvm 内存模型

### java 内存划分

1. 程序计数器（线程私有） 当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址
2. Java 虚拟机栈（线程私有） 存放基本数据类型、对象引用、方法出口等
3. 本地方法栈（线程私有） 和虚拟机栈类似，只不过他服务于本地方法
4. Java 堆（线程共享） 所有实例对象、数组都存放在 java 堆中，GC 回收的地方
5. 方法区（线程共享） 存放已经被加载的类信息、常量、静态变量、及时编译器编译后的代码数据等（即永久带），回收目标主要是常量池的回收和类型的卸载

### Java 堆内存划分（年轻代）

1. 新生成的对象都是先存放在年轻代，目的是快速收集生命周期短的对象
2. 新生代分为 Eden 区 From 区 To 区，默认内存比例 8:1:1，-XX:SurvivorRatio 设置
3. 新生代与老年代内存比例 1:2，-XX:SurvivorRatio 类设置
4. 幸存区的意义 Eden 区每进行一次 Minor GC 就把存活对象送至老年代，老年代很快就会被填满并触发 Major GC，因为老年代内存较大，Full GC 一次比较耗时，有了幸存区可以减少被送到老年代的对象，减少 Full GC 的发生，只有经历了 15 次 Minor GC 还能在新生代中存活的对象才会被送到老年代
5. 两个幸存区的意义 解决了碎片化，刚刚新建的对象在 Eden 区，经历一次 Minor GC，Eden 中存活对象会被移动到第一块 S0 中，Eden 被清空，当 S0 区也存放满了，则将 Eden 区和 S0 区存活对象复制到 S1 区，然后清空 Eden 区和 S0 区，此时 S0 区是空的，然后将 S0 和 S1 区进行交换，保持 S1 区是空的，如果 S1 不足以存放 Eden 和 S0 区存活的对象时，就将存活的对象放到老年代，若老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收
6. 新生代 GC 叫 Minor GC，老年代叫 Major GC，相当于 Full GC，比 Minor GC 慢 10 倍

### Java 堆内存划分（老年代）

1. 老年代存放的对象都是存活比较久的对象（Minor GC 15 次）
2. 老年代也会直接存放一些大对象
3. 老年代触发 GC 的话成为 Major GC 也就是 Full GC

### Java 堆内存划分（持久代）

1. 永久代是方法区的实现，虚拟机上是没有永久代的，方法区只是规范
2. Java1.8 之前 方法区位于永久代中，同时，永久代和堆是相互隔离的，但是物理内存是连续的
3. Java1.8 之后 使用元空间（Metaspace）替代了永久代，方法区存在于元空间，而且不再与堆连续，而且是存在于本地内存，当堆触发 GC 时，本地内存不会触发 GC，当然也可以设置上限和初始化的大小
4. 使用元空间替换永久代是为了避免 OOM，因为永久区的上限并不好确定，设置不好就容易出问题，特别是项目中用了大量的反射来创建对象

## 常见垃圾回收方法

1. 引用计数器：为每个对象创建一个引用计数，有对象引用+1，引用释放-1，为 0 时可回收，例如 c++的 shared_ptr，但是如果循环引用则会出现内存泄漏。
2. 可达性分析算法：虚拟机栈中引用的对象（栈帧），方法区中静态属性引用的对象，方法区中常量用的对象，本地方法栈中引用的对象

## java 垃圾回收算法

1. 标记-清除算法 分标记和清除两个阶段，先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记对象。不需要移动对象，要暂停整个应用，且会产生大量不连续的内存碎片，碎片太多会导致生成大对象空间不足触发新的垃圾回收
2. 复制算法 将可用内存按容量划分为大小相等的两块，每次只使用一块，这块用完了将存活对象复制到另外一块上面，然后把已使用过的空间一次清理掉。不易产生内存碎片，但是内存空间缩减为原来的一半，存活对象越多效率越低
3. 标记-整理算法 让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。结合了标记清楚和复制两种算法的优点
4. 分代收集算法 把 Java 堆内存分为新生代和老年代，这样根据各个年代的特点采用适当的收集算法。老年代每次只有少量对象需要被回收，新生代有大量的对象需要被回收。

## jvm 中的垃圾回收器

### Serial 收集器（新生代，复制算法）

单线程收集器，收集垃圾时会 stop the world

### ParNew 收集器（新生代，复制算法）

是 Serial 收集器的多线程版本

### Parallel Scavenge 收集器（新生代，复制算法）

并发的多线程收集器，追求高吞吐量，高效利用 CPU，吞吐量一般为 99%（100 分钟一分钟在回收垃圾）

### Serial Old 收集器（老年代，标记-整理算法）

Serial 收集器的老年代版，单线程收集

### Parallel Old 收集器（老年代，标记-整理算法）

Paralle Scavenge 的老年代版本

### CMS 收集器（老年代，标记-清除算法）

为了获得最短回收停顿时间为目标的收集器。
运作流程：初始标记，并发标记，重新标记，并发清除，产生大量空间碎片

1. 是一种以获取最短回收停顿时间为目标的收集器。这是因为 CMS 收集器工作时，GC 工作线程可以并发执行，以此来降低收集停顿时间的目的。CMS 收集器仅作用域老年代的收集器，是基于标记-清除算法，他的运作过程分为 初始标记 并发标记 重新标记 并发清除，其中初始标记、重新标记这两个步骤仍需要 Stop-the-world。初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 的过程，重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段停顿时间会稍微长一些，但远比并发标记的时间短
2. CMS 收集器的优点：并发收集，低停顿
3. CMS 收集器的缺点：对 CPU 资源非常敏感，无法处理浮动垃圾，基于标记-清除算法，所以内存碎片会触发 Full GC
4. 新生代如果使用这种算法会产生大量碎片所以不合适
5. 安全点 程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点才能暂停

### G1 收集器（标记-整理）

运作流程：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确控制停顿

1. 重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域，这么做的目的是在进行收集时不必在全对范围内进行。区域划分的好处就是带来了停顿时间可预测收集模型：用户可以指定收集操作在多长时间内完成
2. G1 收集器具备如下特点 并行与并发：充分利用 CPU，使用多个 CPU 缩短 Stop-the-world 停顿的时间，部分其他收集器原来需要停顿 Java 线程执行的 GC 操作，G1 收集器仍然可以通过并发的方式让 Java 程序继续运行，分代收集，空间整合：与 CMS 标记-清楚算法不同，G1 从整体来看是基于标记-整理算法实现的收集器，从局部（两个 Region 之间）上来看就是基于复制算法实现的，意味着 G1 运作期不会产生内存空间碎片，收集后提供规整的内存，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次 GC 可预测的停顿：他可以避免在整个 Java 堆中进行全区域的垃圾收集

### CMS 和 G1 收集器的区别？

1. CMS 收集器是老年代收集器，可以配合新生代的 Serial 和 ParNew 收集器一起使用
2. G1 收集器范围是老年代和新生代，不需要结合其他收集器使用
3. CMS 收集器以最小停顿时间为目标的收集器
4. G1 收集器可预测垃圾回收的停顿时间
5. CMS 收集器使用 标记-清楚 算法，容易产生内存碎片
6. G1 收集器使用 标记-整理算法，降低了内存碎片
7. G1 收集器可以同时解决对象创建和对象回收的问题

### 触发垃圾回收的场景

1. 当 Eden 区和幸存区 From 满时
2. 调用 System.gc()或 Runtime.getRuntime().gc()时，不一定会执行 Full GC
3. 老年代空间不足
4. 方法区空间不足
5. 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存
6. 幸存区 From 到幸存区 To 时发现 To 空间不足转向老年代且老年代可用内存不够
7. 老年代写满会触发 Full GC 8.持久代被写满会触发 Full GC 9.手动调用 gc 方法会触发 Full GC

### stop-the-world

## java 的四种引用类型

1. 强引用 通过 Object obj = new Object()创建的引用
2. 软引用 有用但并非必须的对象，内存不足时会被回收，适合做内存缓存，既能提高查询效率，也不会造成内存泄漏
   系统发生内存溢出异常前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java 中的 SoftReference 表示软引用
3. 弱引用 在下一次 GC 中会被回收掉，ThreadLocal 和 WeakHashMap 都使用了弱引用。Java 中的类 WeakReference 表示弱引用
4. 虚引用 无法从虚引用中拿到对象，被虚引用的对象就跟不存在一样。虚引用用来跟踪垃圾回收情况，或者可以完成垃圾收集器之外的定制化操作。Java NIO 中的堆外内存因为不受 GC 的管理，就是通过虚引用完成。

## 触发内存泄漏的场景

1. 静态类集合 GC 不会收集静态类
2. 各种连接 数据库连接，网络连接，IO 先关如果不 close
3. 强引用 肯定不会回收
4. 监听器的使用 释放内存的同时没有相应删除监听器的时候也可能会导致内存泄漏

## 触发栈内存溢出的场景

1. 栈用来存储基本数据类型，对象应用，操作数栈，动态链接方法，方法出口等信息
2. 栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常，递归方法。
3. 如果能动态扩展又无法申请到足够的内存，或者新建线程时没有足够的内存会抛出 OutOfMemory 异常

## JVM 如何调优

1. 调优的目的主要是减少 GC 的频率和 Full GC 的次数
2. 监控 GC 的状态 通过 JVM 工具查看当前日志，分析当前 JVM 参数设置
3. 通过 jmap -dump:format=b,filename.dump pid 生成堆的 dump 文件 通过 JMX 的 MBean 生成当前的 Heap 信息，也可以用 jmap
4. 分析 dump 文件 是否出现超时日志，GC 频率不高，GC 耗时不高，超过 1-3 秒要优化
5. 调整 GC 类型和内存分配 内存分配过大过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数然后进行测试
6. 不断的试验和试错，分析并找到最合适的参数

## JVM 相关工具

1. jps 查看所有 HotSport 虚拟机进程
2. jstat 用于收集 Hotspot 虚拟机各方面的运行数据
3. jinfo 显示虚拟机配置信息
4. jmap 生成虚拟机的内存快照，生成 heapdump 文件
5. jhat 用于分析 heapdump 文件，会生成网页
6. jstack 显示虚拟机的线程快照

## java 命令常用参数

- -Xss512K 指定 JVM 的栈大小
- Xms 指定 JVM 初始占用的堆内存大小
- -Xmx 指定 JVM 最大堆内存大小
