# 分布式

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [分布式](#分布式)
  - [分布式唯一 id 生成方法](#分布式唯一-id-生成方法)
    - [snowflake 雪花算法原理](#snowflake-雪花算法原理)
  - [分布式 CAP 定理](#分布式-cap-定理)
  - [分布式事务](#分布式事务)
    - [两阶段提交 2PC](#两阶段提交-2pc)
    - [事务补偿 TCC](#事务补偿-tcc)
  - [分布式锁](#分布式锁)
  - [分布式一致性 hash 算法](#分布式一致性-hash-算法)

<!-- /code_chunk_output -->

## 分布式唯一 id 生成方法

| 方法               | 描述                                                                                                                             | 优点                                                                                                       | 缺点                                                                                   |
| :----------------- | :------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------- |
| uuid               | 算法的核心思想是结合机器的网卡、当地时间、一个随记数来生成 UUID                                                                  | 本地生成，生成简单，性能好，没有高可用风险                                                                 | 长度过长，存储冗余，且无序不可读，查询效率低                                           |
| 数据库自增 id      | 使用数据库的 id 自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。 | 数据库生成的 ID 绝对有序，高可用实现方式简单                                                               | 需要独立部署数据库实例，成本高，有性能瓶颈                                             |
| 批量申请自增 ID    | 一次按需批量生成多个 ID，每次生成都需要访问数据库，将数据库修改为最大的 ID 值，并在内存中记录当前值及最大值                      | 避免了每次生成 ID 都要访问数据库并带来压力，提高性能                                                       | 属于本地生成策略，存在单点故障，服务重启造成 ID 不连续                                 |
| redis incr/incrby  | Redis 的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的            | 不依赖于数据库，灵活方便，且性能优于数据库；数字 ID 天然排序，对分页或者需要排序的结果很有帮助             | 如果系统中没有 Redis，还需要引入新的组件，增加系统复杂度；需要编码和配置的工作量比较大 |
| snowflake 雪花算法 | 使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且 ID 引入了时间戳，保持自增性且不重复            | 整体上按照时间自增排序，并且整个分布式系统内不会产生 ID 碰撞(由数据中心 ID 和机器 ID 作区分)，并且效率较高 | 依赖机器时钟，如果时钟回调，会导致冲突                                                 |

### snowflake 雪花算法原理

![snowflake](snowflake.png)

- 1 bit，是无意义的：因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。
- 41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1 个毫秒值，换算成年就是表示 69 年的时间。
- 10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 2 ^ 5 个机房（32 个机房），每个机房里可以代表 2 ^ 5 个机器（32 台机器），这里可以随意拆分，比如拿出 4 位标识业务号，其他 6 位作为机器号。可以随意组合。
- 12 bit：这个是用来记录同一个毫秒内产生的不同 id。12 bit 可以代表的最大正整数是 2 ^ 12 - 1 = 4096，也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。也就是同一毫秒内同一台机器所生成的最大 ID 数量为 4096

假设某个服务要生成一个全局唯一 id，那么就可以发送一个请求给部署了 SnowFlake 算法的系统，由这个 SnowFlake 算法系统来生成唯一 id。这个 SnowFlake 算法系统首先肯定是知道自己所在的机器号，接着 SnowFlake 算法系统接收到这个请求之后，首先就会用二进制位运算的方式生成一个 64 bit 的 long 型 id，64 个 bit 中的第一个 bit 是无意义的。接着用当前时间戳（单位到毫秒）占用 41 个 bit，然后接着 10 个 bit 设置机器 id。最后再判断一下，当前这台机房的这台机器上这一毫秒内，这是第几个请求，给这次生成 id 的请求累加一个序号，作为最后的 12 个 bit。

## 分布式 CAP 定理

1. 针对的是多个节点之间的读写一致提出的
2. CAP 包括 一致性（Consistency），可用性（Availability），分区容错性（Partition tolerance） 2.一致性 分布式系统完成某个写操作后任何读操作，都应该获取到该写操作写的的最新值，相当于要求分布式系统中的各节点时刻保持数据的一致性

## 分布式事务

### 两阶段提交 2PC

两阶段提交（2PC） 引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。准备阶段：协调者询问参与者事务是否执行成功，参与者发回事务执行结果，提交阶段：如果事务在每个参与者上都执行成功，事务协调器者发送通知让参与者提交事务，否则协调者发送通知让参与者回滚事务。在准备阶段，参与者执行了事务但是未提交，只有在提交阶段收到协调者发来的通知后才进行提交或者回滚。存在的问题：同步阻塞，单点问题，数据不一致，没有容错机制

### 事务补偿 TCC

## 分布式锁

- Memcached：利用 Memcached 的 add 命令。此命令是原子性操作，只有在 key 不存在的情况下，才能 add 成功，也就意味着线程得到了锁。
- Redis：和 Memcached 的方式类似，利用 Redis 的 setnx 命令。此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。
- Zookeeper：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。

## 分布式一致性 hash 算法

## 分布式系统接口幂等性
